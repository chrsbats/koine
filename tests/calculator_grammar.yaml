start_rule: program

rules:
  program:
    sequence:
      - { rule: expression }
      - zero_or_more:
          sequence:
            - { rule: separator }
            - { rule: expression }
      - { rule: trailing_whitespace }

  # Lowest precedence: Addition/Subtraction (Left-Associative)
  expression:
    ast: { structure: "left_associative_op" }
    transpile: { template: "({op} {left} {right})" }
    sequence:
      - { rule: term }
      - zero_or_more:
          sequence: [{rule: _}, {rule: add_op}, {rule: _}, {rule: term}]

  # Next precedence: Multiplication/Division (Left-Associative)
  term:
    ast: { structure: "left_associative_op" }
    transpile: { template: "({op} {left} {right})" }
    sequence:
      - { rule: power } # <-- Calls 'power' instead of 'factor'
      - zero_or_more:
          sequence: [{rule: _}, {rule: mul_op}, {rule: _}, {rule: power}]

  # New Rule: Highest precedence operator (Right-Associative)
  power:
    ast: { structure: "right_associative_op" }
    transpile: { template: "({op} {left} {right})" }
    sequence:
      - { rule: factor } # The left-hand side
      - optional: # The (op expr)? part
          sequence:
            - { rule: _ }
            - { rule: power_op }
            - { rule: _ }
            - { rule: power } # <-- The right-recursive call

  # Base of the expression tree
  factor:
    ast: { promote: true }
    transpile: { promote: true }
    choice:
      - { rule: number }
      - sequence:
          - { literal: "(" }
          - { rule: _ }
          - { rule: expression }
          - { rule: _ }
          - { literal: ")" }

  add_op:
    ast: { leaf: true }
    choice:
      - { literal: "+", transpile: { value: "add" } }
      - { literal: "-", transpile: { value: "sub" } }

  mul_op:
    ast: { leaf: true }
    choice:
      - { literal: "*", transpile: { value: "mul" } }
      - { literal: "/", transpile: { value: "div" } }

  # New operator definition
  power_op:
    ast: { leaf: true }
    literal: "^"
    transpile: { value: "pow" }

  number:
    ast: { leaf: true, type: "number" }
    transpile: { use: "value" }
    regex: "-?\\d+"

  separator:
    ast: { discard: true }
    regex: "[ \\t]*\\n[\\s]*"
  
  _:
    ast: { discard: true }
    regex: "[ \\t]*"

  trailing_whitespace:
    ast: { discard: true }
    regex: "\\s*"
